// Generated by gencpp from file game_controller/GameState.msg
// DO NOT EDIT!


#ifndef GAME_CONTROLLER_MESSAGE_GAMESTATE_H
#define GAME_CONTROLLER_MESSAGE_GAMESTATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace game_controller
{
template <class ContainerAllocator>
struct GameState_
{
  typedef GameState_<ContainerAllocator> Type;

  GameState_()
    : header()
    , gameState(0)
    , secondaryState(0)
    , secondrayStateTeam(0)
    , firstHalf(false)
    , ownScore(0)
    , rivalScore(0)
    , secondsRemaining(0)
    , secondary_seconds_remaining(0)
    , penalty(0)
    , hasKickOff(false)
    , penalized(false)
    , secondsTillUnpenalized(0)
    , allowedToMove(false)
    , dropInTeam(false)
    , dropInTime(0)
    , penaltyShot(0)
    , singleShots(0)
    , coach_message()  {
    }
  GameState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , gameState(0)
    , secondaryState(0)
    , secondrayStateTeam(0)
    , firstHalf(false)
    , ownScore(0)
    , rivalScore(0)
    , secondsRemaining(0)
    , secondary_seconds_remaining(0)
    , penalty(0)
    , hasKickOff(false)
    , penalized(false)
    , secondsTillUnpenalized(0)
    , allowedToMove(false)
    , dropInTeam(false)
    , dropInTime(0)
    , penaltyShot(0)
    , singleShots(0)
    , coach_message(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint8_t _gameState_type;
  _gameState_type gameState;

   typedef uint8_t _secondaryState_type;
  _secondaryState_type secondaryState;

   typedef uint8_t _secondrayStateTeam_type;
  _secondrayStateTeam_type secondrayStateTeam;

   typedef uint8_t _firstHalf_type;
  _firstHalf_type firstHalf;

   typedef uint8_t _ownScore_type;
  _ownScore_type ownScore;

   typedef uint8_t _rivalScore_type;
  _rivalScore_type rivalScore;

   typedef int16_t _secondsRemaining_type;
  _secondsRemaining_type secondsRemaining;

   typedef uint16_t _secondary_seconds_remaining_type;
  _secondary_seconds_remaining_type secondary_seconds_remaining;

   typedef uint8_t _penalty_type;
  _penalty_type penalty;

   typedef uint8_t _hasKickOff_type;
  _hasKickOff_type hasKickOff;

   typedef uint8_t _penalized_type;
  _penalized_type penalized;

   typedef uint16_t _secondsTillUnpenalized_type;
  _secondsTillUnpenalized_type secondsTillUnpenalized;

   typedef uint8_t _allowedToMove_type;
  _allowedToMove_type allowedToMove;

   typedef uint8_t _dropInTeam_type;
  _dropInTeam_type dropInTeam;

   typedef uint16_t _dropInTime_type;
  _dropInTime_type dropInTime;

   typedef uint8_t _penaltyShot_type;
  _penaltyShot_type penaltyShot;

   typedef uint16_t _singleShots_type;
  _singleShots_type singleShots;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _coach_message_type;
  _coach_message_type coach_message;



  enum {
    MANUAL = 15u,
  };


  typedef boost::shared_ptr< ::game_controller::GameState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::game_controller::GameState_<ContainerAllocator> const> ConstPtr;

}; // struct GameState_

typedef ::game_controller::GameState_<std::allocator<void> > GameState;

typedef boost::shared_ptr< ::game_controller::GameState > GameStatePtr;
typedef boost::shared_ptr< ::game_controller::GameState const> GameStateConstPtr;

// constants requiring out of line definition

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::game_controller::GameState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::game_controller::GameState_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace game_controller

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'game_controller': ['/home/alfarobi/alfarobi_ws/src/ALFAROBI-Communication/game_controller/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::game_controller::GameState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::game_controller::GameState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::game_controller::GameState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::game_controller::GameState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::game_controller::GameState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::game_controller::GameState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::game_controller::GameState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "9e87745f53267ba5d95d9900fdc4cf02";
  }

  static const char* value(const ::game_controller::GameState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x9e87745f53267ba5ULL;
  static const uint64_t static_value2 = 0xd95d9900fdc4cf02ULL;
};

template<class ContainerAllocator>
struct DataType< ::game_controller::GameState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "game_controller/GameState";
  }

  static const char* value(const ::game_controller::GameState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::game_controller::GameState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# This message provides all information from the game controller\n\
# for additional information see documentation of the game controller\n\
# https://github.com/bhuman/GameController\n\
\n\
\n\
std_msgs/Header header\n\
\n\
#uint8 GAMESTATE_INITAL=0\n\
#uint8 GAMESTATE_READY=1\n\
#uint8 GAMESTATE_SET=2\n\
#uint8 GAMESTATE_PLAYING=3\n\
#uint8 GAMESTATE_FINISHED=4\n\
uint8 gameState\n\
\n\
#uint8 STATE_NORMAL = 0\n\
#uint8 STATE_PENALTYSHOOT = 1\n\
#uint8 STATE_OVERTIME = 2\n\
#uint8 STATE_TIMEOUT = 3\n\
#uint8 STATE_FREEKICK = 4\n\
#uint8 STATE_PENALTYKICK = 5\n\
uint8 secondaryState\n\
\n\
# For newest version of game controller\n\
# Tells which team has the free kick or penalty kick\n\
uint8 secondrayStateTeam\n\
\n\
bool firstHalf\n\
uint8 ownScore\n\
uint8 rivalScore\n\
\n\
# Seconds remaining for the game half\n\
int16 secondsRemaining\n\
# Seconds remaining for things like kickoff\n\
uint16 secondary_seconds_remaining\n\
\n\
#uint8 NONE=0\n\
#uint8 PENALTY_HL_KID_BALL_MANIPULATION=30\n\
#uint8 PENALTY_HL_KID_PHYSICAL_CONTACT=31\n\
#uint8 PENALTY_HL_KID_ILLEGAL_ATTACK=22\n\
#uint8 PENALTY_HL_KID_ILLEGAL_DEFENSE=4\n\
#uint8 PENALTY_HL_KID_REQUEST_FOR_PICKUP=34\n\
#uint8 PENALTY_HL_KID_REQUEST_FOR_SERVICE=35\n\
uint8 MANUAL=15\n\
\n\
uint8 penalty\n\
bool hasKickOff\n\
bool penalized\n\
uint16 secondsTillUnpenalized\n\
\n\
# Allowed to move is different from penalized.\n\
# You can for example be not allowed to move due to the current state of the game\n\
bool allowedToMove\n\
\n\
bool dropInTeam\n\
uint16 dropInTime\n\
\n\
uint8 penaltyShot\n\
uint16 singleShots\n\
\n\
string coach_message\n\
\n\
\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
  }

  static const char* value(const ::game_controller::GameState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::game_controller::GameState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.gameState);
      stream.next(m.secondaryState);
      stream.next(m.secondrayStateTeam);
      stream.next(m.firstHalf);
      stream.next(m.ownScore);
      stream.next(m.rivalScore);
      stream.next(m.secondsRemaining);
      stream.next(m.secondary_seconds_remaining);
      stream.next(m.penalty);
      stream.next(m.hasKickOff);
      stream.next(m.penalized);
      stream.next(m.secondsTillUnpenalized);
      stream.next(m.allowedToMove);
      stream.next(m.dropInTeam);
      stream.next(m.dropInTime);
      stream.next(m.penaltyShot);
      stream.next(m.singleShots);
      stream.next(m.coach_message);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct GameState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::game_controller::GameState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::game_controller::GameState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "gameState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gameState);
    s << indent << "secondaryState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secondaryState);
    s << indent << "secondrayStateTeam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secondrayStateTeam);
    s << indent << "firstHalf: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.firstHalf);
    s << indent << "ownScore: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ownScore);
    s << indent << "rivalScore: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rivalScore);
    s << indent << "secondsRemaining: ";
    Printer<int16_t>::stream(s, indent + "  ", v.secondsRemaining);
    s << indent << "secondary_seconds_remaining: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.secondary_seconds_remaining);
    s << indent << "penalty: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.penalty);
    s << indent << "hasKickOff: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.hasKickOff);
    s << indent << "penalized: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.penalized);
    s << indent << "secondsTillUnpenalized: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.secondsTillUnpenalized);
    s << indent << "allowedToMove: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.allowedToMove);
    s << indent << "dropInTeam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dropInTeam);
    s << indent << "dropInTime: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.dropInTime);
    s << indent << "penaltyShot: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.penaltyShot);
    s << indent << "singleShots: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.singleShots);
    s << indent << "coach_message: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.coach_message);
  }
};

} // namespace message_operations
} // namespace ros

#endif // GAME_CONTROLLER_MESSAGE_GAMESTATE_H
