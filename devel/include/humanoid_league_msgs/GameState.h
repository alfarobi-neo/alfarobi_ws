// Generated by gencpp from file humanoid_league_msgs/GameState.msg
// DO NOT EDIT!


#ifndef HUMANOID_LEAGUE_MSGS_MESSAGE_GAMESTATE_H
#define HUMANOID_LEAGUE_MSGS_MESSAGE_GAMESTATE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace humanoid_league_msgs
{
template <class ContainerAllocator>
struct GameState_
{
  typedef GameState_<ContainerAllocator> Type;

  GameState_()
    : header()
    , gameState(0)
    , secondaryState(0)
    , secondrayStateTeam(0)
    , firstHalf(false)
    , ownScore(0)
    , rivalScore(0)
    , secondsRemaining(0)
    , secondary_seconds_remaining(0)
    , hasKickOff(false)
    , penalized(false)
    , secondsTillUnpenalized(0)
    , allowedToMove(false)
    , dropInTeam(false)
    , dropInTime(0)
    , penaltyShot(0)
    , singleShots(0)
    , coach_message()  {
    }
  GameState_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , gameState(0)
    , secondaryState(0)
    , secondrayStateTeam(0)
    , firstHalf(false)
    , ownScore(0)
    , rivalScore(0)
    , secondsRemaining(0)
    , secondary_seconds_remaining(0)
    , hasKickOff(false)
    , penalized(false)
    , secondsTillUnpenalized(0)
    , allowedToMove(false)
    , dropInTeam(false)
    , dropInTime(0)
    , penaltyShot(0)
    , singleShots(0)
    , coach_message(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint8_t _gameState_type;
  _gameState_type gameState;

   typedef uint8_t _secondaryState_type;
  _secondaryState_type secondaryState;

   typedef uint8_t _secondrayStateTeam_type;
  _secondrayStateTeam_type secondrayStateTeam;

   typedef uint8_t _firstHalf_type;
  _firstHalf_type firstHalf;

   typedef uint8_t _ownScore_type;
  _ownScore_type ownScore;

   typedef uint8_t _rivalScore_type;
  _rivalScore_type rivalScore;

   typedef int16_t _secondsRemaining_type;
  _secondsRemaining_type secondsRemaining;

   typedef uint16_t _secondary_seconds_remaining_type;
  _secondary_seconds_remaining_type secondary_seconds_remaining;

   typedef uint8_t _hasKickOff_type;
  _hasKickOff_type hasKickOff;

   typedef uint8_t _penalized_type;
  _penalized_type penalized;

   typedef uint16_t _secondsTillUnpenalized_type;
  _secondsTillUnpenalized_type secondsTillUnpenalized;

   typedef uint8_t _allowedToMove_type;
  _allowedToMove_type allowedToMove;

   typedef uint8_t _dropInTeam_type;
  _dropInTeam_type dropInTeam;

   typedef uint16_t _dropInTime_type;
  _dropInTime_type dropInTime;

   typedef uint8_t _penaltyShot_type;
  _penaltyShot_type penaltyShot;

   typedef uint16_t _singleShots_type;
  _singleShots_type singleShots;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _coach_message_type;
  _coach_message_type coach_message;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(GAMESTATE_INITAL)
  #undef GAMESTATE_INITAL
#endif
#if defined(_WIN32) && defined(GAMESTATE_READY)
  #undef GAMESTATE_READY
#endif
#if defined(_WIN32) && defined(GAMESTATE_SET)
  #undef GAMESTATE_SET
#endif
#if defined(_WIN32) && defined(GAMESTATE_PLAYING)
  #undef GAMESTATE_PLAYING
#endif
#if defined(_WIN32) && defined(GAMESTATE_FINISHED)
  #undef GAMESTATE_FINISHED
#endif
#if defined(_WIN32) && defined(STATE_NORMAL)
  #undef STATE_NORMAL
#endif
#if defined(_WIN32) && defined(STATE_PENALTYSHOOT)
  #undef STATE_PENALTYSHOOT
#endif
#if defined(_WIN32) && defined(STATE_OVERTIME)
  #undef STATE_OVERTIME
#endif
#if defined(_WIN32) && defined(STATE_TIMEOUT)
  #undef STATE_TIMEOUT
#endif
#if defined(_WIN32) && defined(STATE_FREEKICK)
  #undef STATE_FREEKICK
#endif
#if defined(_WIN32) && defined(STATE_PENALTYKICK)
  #undef STATE_PENALTYKICK
#endif

  enum {
    GAMESTATE_INITAL = 0u,
    GAMESTATE_READY = 1u,
    GAMESTATE_SET = 2u,
    GAMESTATE_PLAYING = 3u,
    GAMESTATE_FINISHED = 4u,
    STATE_NORMAL = 0u,
    STATE_PENALTYSHOOT = 1u,
    STATE_OVERTIME = 2u,
    STATE_TIMEOUT = 3u,
    STATE_FREEKICK = 4u,
    STATE_PENALTYKICK = 5u,
  };


  typedef boost::shared_ptr< ::humanoid_league_msgs::GameState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::humanoid_league_msgs::GameState_<ContainerAllocator> const> ConstPtr;

}; // struct GameState_

typedef ::humanoid_league_msgs::GameState_<std::allocator<void> > GameState;

typedef boost::shared_ptr< ::humanoid_league_msgs::GameState > GameStatePtr;
typedef boost::shared_ptr< ::humanoid_league_msgs::GameState const> GameStateConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::humanoid_league_msgs::GameState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::humanoid_league_msgs::GameState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::humanoid_league_msgs::GameState_<ContainerAllocator1> & lhs, const ::humanoid_league_msgs::GameState_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.gameState == rhs.gameState &&
    lhs.secondaryState == rhs.secondaryState &&
    lhs.secondrayStateTeam == rhs.secondrayStateTeam &&
    lhs.firstHalf == rhs.firstHalf &&
    lhs.ownScore == rhs.ownScore &&
    lhs.rivalScore == rhs.rivalScore &&
    lhs.secondsRemaining == rhs.secondsRemaining &&
    lhs.secondary_seconds_remaining == rhs.secondary_seconds_remaining &&
    lhs.hasKickOff == rhs.hasKickOff &&
    lhs.penalized == rhs.penalized &&
    lhs.secondsTillUnpenalized == rhs.secondsTillUnpenalized &&
    lhs.allowedToMove == rhs.allowedToMove &&
    lhs.dropInTeam == rhs.dropInTeam &&
    lhs.dropInTime == rhs.dropInTime &&
    lhs.penaltyShot == rhs.penaltyShot &&
    lhs.singleShots == rhs.singleShots &&
    lhs.coach_message == rhs.coach_message;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::humanoid_league_msgs::GameState_<ContainerAllocator1> & lhs, const ::humanoid_league_msgs::GameState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace humanoid_league_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::humanoid_league_msgs::GameState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::humanoid_league_msgs::GameState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::humanoid_league_msgs::GameState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::humanoid_league_msgs::GameState_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::humanoid_league_msgs::GameState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::humanoid_league_msgs::GameState_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::humanoid_league_msgs::GameState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "36ea982046fabfdd283bc1d352aa9438";
  }

  static const char* value(const ::humanoid_league_msgs::GameState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x36ea982046fabfddULL;
  static const uint64_t static_value2 = 0x283bc1d352aa9438ULL;
};

template<class ContainerAllocator>
struct DataType< ::humanoid_league_msgs::GameState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "humanoid_league_msgs/GameState";
  }

  static const char* value(const ::humanoid_league_msgs::GameState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::humanoid_league_msgs::GameState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# This message provides all information from the game controller\n"
"# for additional information see documentation of the game controller\n"
"# https://github.com/bhuman/GameController\n"
"\n"
"\n"
"std_msgs/Header header\n"
"\n"
"uint8 GAMESTATE_INITAL=0\n"
"uint8 GAMESTATE_READY=1\n"
"uint8 GAMESTATE_SET=2\n"
"uint8 GAMESTATE_PLAYING=3\n"
"uint8 GAMESTATE_FINISHED=4\n"
"uint8 gameState\n"
"\n"
"uint8 STATE_NORMAL = 0\n"
"uint8 STATE_PENALTYSHOOT = 1\n"
"uint8 STATE_OVERTIME = 2\n"
"uint8 STATE_TIMEOUT = 3\n"
"uint8 STATE_FREEKICK = 4\n"
"uint8 STATE_PENALTYKICK = 5\n"
"uint8 secondaryState\n"
"\n"
"# For newest version of game controller\n"
"# Tells which team has the free kick or penalty kick\n"
"uint8 secondrayStateTeam\n"
"\n"
"bool firstHalf\n"
"uint8 ownScore\n"
"uint8 rivalScore\n"
"\n"
"# Seconds remaining for the game half\n"
"int16 secondsRemaining\n"
"# Seconds remaining for things like kickoff\n"
"uint16 secondary_seconds_remaining\n"
"\n"
"bool hasKickOff\n"
"bool penalized\n"
"uint16 secondsTillUnpenalized\n"
"# Allowed to move is different from penalized.\n"
"# You can for example be not allowed to move due to the current state of the game\n"
"bool allowedToMove\n"
"\n"
"bool dropInTeam\n"
"uint16 dropInTime\n"
"\n"
"uint8 penaltyShot\n"
"uint16 singleShots\n"
"\n"
"string coach_message\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::humanoid_league_msgs::GameState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::humanoid_league_msgs::GameState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.gameState);
      stream.next(m.secondaryState);
      stream.next(m.secondrayStateTeam);
      stream.next(m.firstHalf);
      stream.next(m.ownScore);
      stream.next(m.rivalScore);
      stream.next(m.secondsRemaining);
      stream.next(m.secondary_seconds_remaining);
      stream.next(m.hasKickOff);
      stream.next(m.penalized);
      stream.next(m.secondsTillUnpenalized);
      stream.next(m.allowedToMove);
      stream.next(m.dropInTeam);
      stream.next(m.dropInTime);
      stream.next(m.penaltyShot);
      stream.next(m.singleShots);
      stream.next(m.coach_message);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct GameState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::humanoid_league_msgs::GameState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::humanoid_league_msgs::GameState_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "gameState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gameState);
    s << indent << "secondaryState: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secondaryState);
    s << indent << "secondrayStateTeam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.secondrayStateTeam);
    s << indent << "firstHalf: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.firstHalf);
    s << indent << "ownScore: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ownScore);
    s << indent << "rivalScore: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rivalScore);
    s << indent << "secondsRemaining: ";
    Printer<int16_t>::stream(s, indent + "  ", v.secondsRemaining);
    s << indent << "secondary_seconds_remaining: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.secondary_seconds_remaining);
    s << indent << "hasKickOff: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.hasKickOff);
    s << indent << "penalized: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.penalized);
    s << indent << "secondsTillUnpenalized: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.secondsTillUnpenalized);
    s << indent << "allowedToMove: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.allowedToMove);
    s << indent << "dropInTeam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dropInTeam);
    s << indent << "dropInTime: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.dropInTime);
    s << indent << "penaltyShot: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.penaltyShot);
    s << indent << "singleShots: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.singleShots);
    s << indent << "coach_message: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.coach_message);
  }
};

} // namespace message_operations
} // namespace ros

#endif // HUMANOID_LEAGUE_MSGS_MESSAGE_GAMESTATE_H
