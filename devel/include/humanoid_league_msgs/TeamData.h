// Generated by gencpp from file humanoid_league_msgs/TeamData.msg
// DO NOT EDIT!


#ifndef HUMANOID_LEAGUE_MSGS_MESSAGE_TEAMDATA_H
#define HUMANOID_LEAGUE_MSGS_MESSAGE_TEAMDATA_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <geometry_msgs/Pose2D.h>
#include <humanoid_league_msgs/Position2D.h>
#include <humanoid_league_msgs/Position2D.h>
#include <humanoid_league_msgs/Position2D.h>
#include <humanoid_league_msgs/Position2D.h>
#include <humanoid_league_msgs/Position2D.h>
#include <humanoid_league_msgs/Position2D.h>
#include <humanoid_league_msgs/Position2D.h>
#include <humanoid_league_msgs/Position2D.h>
#include <humanoid_league_msgs/Position2D.h>

namespace humanoid_league_msgs
{
template <class ContainerAllocator>
struct TeamData_
{
  typedef TeamData_<ContainerAllocator> Type;

  TeamData_()
    : header()
    , robot_ids()
    , role()
    , action()
    , state()
    , robot_positions()
    , ball_relative()
    , oppgoal_relative()
    , opponent_robot_a()
    , opponent_robot_b()
    , opponent_robot_c()
    , opponent_robot_d()
    , team_robot_a()
    , team_robot_b()
    , team_robot_c()
    , avg_walking_speed()
    , time_to_position_at_ball()
    , max_kicking_distance()
    , offensive_side()  {
    }
  TeamData_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , robot_ids(_alloc)
    , role(_alloc)
    , action(_alloc)
    , state(_alloc)
    , robot_positions(_alloc)
    , ball_relative(_alloc)
    , oppgoal_relative(_alloc)
    , opponent_robot_a(_alloc)
    , opponent_robot_b(_alloc)
    , opponent_robot_c(_alloc)
    , opponent_robot_d(_alloc)
    , team_robot_a(_alloc)
    , team_robot_b(_alloc)
    , team_robot_c(_alloc)
    , avg_walking_speed(_alloc)
    , time_to_position_at_ball(_alloc)
    , max_kicking_distance(_alloc)
    , offensive_side(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef std::vector<uint8_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>> _robot_ids_type;
  _robot_ids_type robot_ids;

   typedef std::vector<uint8_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>> _role_type;
  _role_type role;

   typedef std::vector<uint8_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>> _action_type;
  _action_type action;

   typedef std::vector<uint8_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>> _state_type;
  _state_type state;

   typedef std::vector< ::geometry_msgs::Pose2D_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::geometry_msgs::Pose2D_<ContainerAllocator> >> _robot_positions_type;
  _robot_positions_type robot_positions;

   typedef std::vector< ::humanoid_league_msgs::Position2D_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >> _ball_relative_type;
  _ball_relative_type ball_relative;

   typedef std::vector< ::humanoid_league_msgs::Position2D_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >> _oppgoal_relative_type;
  _oppgoal_relative_type oppgoal_relative;

   typedef std::vector< ::humanoid_league_msgs::Position2D_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >> _opponent_robot_a_type;
  _opponent_robot_a_type opponent_robot_a;

   typedef std::vector< ::humanoid_league_msgs::Position2D_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >> _opponent_robot_b_type;
  _opponent_robot_b_type opponent_robot_b;

   typedef std::vector< ::humanoid_league_msgs::Position2D_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >> _opponent_robot_c_type;
  _opponent_robot_c_type opponent_robot_c;

   typedef std::vector< ::humanoid_league_msgs::Position2D_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >> _opponent_robot_d_type;
  _opponent_robot_d_type opponent_robot_d;

   typedef std::vector< ::humanoid_league_msgs::Position2D_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >> _team_robot_a_type;
  _team_robot_a_type team_robot_a;

   typedef std::vector< ::humanoid_league_msgs::Position2D_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >> _team_robot_b_type;
  _team_robot_b_type team_robot_b;

   typedef std::vector< ::humanoid_league_msgs::Position2D_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >> _team_robot_c_type;
  _team_robot_c_type team_robot_c;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _avg_walking_speed_type;
  _avg_walking_speed_type avg_walking_speed;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _time_to_position_at_ball_type;
  _time_to_position_at_ball_type time_to_position_at_ball;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _max_kicking_distance_type;
  _max_kicking_distance_type max_kicking_distance;

   typedef std::vector<uint8_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>> _offensive_side_type;
  _offensive_side_type offensive_side;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(ROLE_IDLING)
  #undef ROLE_IDLING
#endif
#if defined(_WIN32) && defined(ROLE_OTHER)
  #undef ROLE_OTHER
#endif
#if defined(_WIN32) && defined(ROLE_STRIKER)
  #undef ROLE_STRIKER
#endif
#if defined(_WIN32) && defined(ROLE_SUPPORTER)
  #undef ROLE_SUPPORTER
#endif
#if defined(_WIN32) && defined(ROLE_DEFENDER)
  #undef ROLE_DEFENDER
#endif
#if defined(_WIN32) && defined(ROLE_GOALIE)
  #undef ROLE_GOALIE
#endif
#if defined(_WIN32) && defined(ACTION_UNDEFINED)
  #undef ACTION_UNDEFINED
#endif
#if defined(_WIN32) && defined(ACTION_POSITIONING)
  #undef ACTION_POSITIONING
#endif
#if defined(_WIN32) && defined(ACTION_GOING_TO_BALL)
  #undef ACTION_GOING_TO_BALL
#endif
#if defined(_WIN32) && defined(ACTION_TRYING_TO_SCORE)
  #undef ACTION_TRYING_TO_SCORE
#endif
#if defined(_WIN32) && defined(ACTION_WAITING)
  #undef ACTION_WAITING
#endif
#if defined(_WIN32) && defined(STATE_INACTIVE)
  #undef STATE_INACTIVE
#endif
#if defined(_WIN32) && defined(STATE_ACTIVE)
  #undef STATE_ACTIVE
#endif
#if defined(_WIN32) && defined(STATE_PENALIZED)
  #undef STATE_PENALIZED
#endif
#if defined(_WIN32) && defined(UNSPECIFIED)
  #undef UNSPECIFIED
#endif
#if defined(_WIN32) && defined(LEFT)
  #undef LEFT
#endif
#if defined(_WIN32) && defined(RIGHT)
  #undef RIGHT
#endif
#if defined(_WIN32) && defined(CENTER)
  #undef CENTER
#endif

  enum {
    ROLE_IDLING = 0u,
    ROLE_OTHER = 1u,
    ROLE_STRIKER = 2u,
    ROLE_SUPPORTER = 3u,
    ROLE_DEFENDER = 4u,
    ROLE_GOALIE = 5u,
    ACTION_UNDEFINED = 0u,
    ACTION_POSITIONING = 1u,
    ACTION_GOING_TO_BALL = 2u,
    ACTION_TRYING_TO_SCORE = 3u,
    ACTION_WAITING = 4u,
    STATE_INACTIVE = 0u,
    STATE_ACTIVE = 1u,
    STATE_PENALIZED = 2u,
    UNSPECIFIED = 0u,
    LEFT = 1u,
    RIGHT = 2u,
    CENTER = 3u,
  };


  typedef boost::shared_ptr< ::humanoid_league_msgs::TeamData_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::humanoid_league_msgs::TeamData_<ContainerAllocator> const> ConstPtr;

}; // struct TeamData_

typedef ::humanoid_league_msgs::TeamData_<std::allocator<void> > TeamData;

typedef boost::shared_ptr< ::humanoid_league_msgs::TeamData > TeamDataPtr;
typedef boost::shared_ptr< ::humanoid_league_msgs::TeamData const> TeamDataConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::humanoid_league_msgs::TeamData_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::humanoid_league_msgs::TeamData_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::humanoid_league_msgs::TeamData_<ContainerAllocator1> & lhs, const ::humanoid_league_msgs::TeamData_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.robot_ids == rhs.robot_ids &&
    lhs.role == rhs.role &&
    lhs.action == rhs.action &&
    lhs.state == rhs.state &&
    lhs.robot_positions == rhs.robot_positions &&
    lhs.ball_relative == rhs.ball_relative &&
    lhs.oppgoal_relative == rhs.oppgoal_relative &&
    lhs.opponent_robot_a == rhs.opponent_robot_a &&
    lhs.opponent_robot_b == rhs.opponent_robot_b &&
    lhs.opponent_robot_c == rhs.opponent_robot_c &&
    lhs.opponent_robot_d == rhs.opponent_robot_d &&
    lhs.team_robot_a == rhs.team_robot_a &&
    lhs.team_robot_b == rhs.team_robot_b &&
    lhs.team_robot_c == rhs.team_robot_c &&
    lhs.avg_walking_speed == rhs.avg_walking_speed &&
    lhs.time_to_position_at_ball == rhs.time_to_position_at_ball &&
    lhs.max_kicking_distance == rhs.max_kicking_distance &&
    lhs.offensive_side == rhs.offensive_side;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::humanoid_league_msgs::TeamData_<ContainerAllocator1> & lhs, const ::humanoid_league_msgs::TeamData_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace humanoid_league_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::humanoid_league_msgs::TeamData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::humanoid_league_msgs::TeamData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::humanoid_league_msgs::TeamData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::humanoid_league_msgs::TeamData_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::humanoid_league_msgs::TeamData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::humanoid_league_msgs::TeamData_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::humanoid_league_msgs::TeamData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "3c1658268445f044e3a6e26e5ab92357";
  }

  static const char* value(const ::humanoid_league_msgs::TeamData_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x3c1658268445f044ULL;
  static const uint64_t static_value2 = 0xe3a6e26e5ab92357ULL;
};

template<class ContainerAllocator>
struct DataType< ::humanoid_league_msgs::TeamData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "humanoid_league_msgs/TeamData";
  }

  static const char* value(const ::humanoid_league_msgs::TeamData_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::humanoid_league_msgs::TeamData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# This message contains all information provided by the mitecom standard for team communication.\n"
"# Everything is in meters (ROS standard) not to be confused with millimeters (mitecom standard)!\n"
"# Set belief values to 0 if object was not recognized.\n"
"# More information here: https://github.com/fumanoids/mitecom\n"
"\n"
"std_msgs/Header header\n"
"\n"
"# Every value is an array because we can have multiple robots communicating with us.\n"
"# The values match with the robot ids\n"
"uint8[] robot_ids\n"
"\n"
"uint8 ROLE_IDLING=0\n"
"uint8 ROLE_OTHER=1\n"
"uint8 ROLE_STRIKER=2\n"
"uint8 ROLE_SUPPORTER=3\n"
"uint8 ROLE_DEFENDER=4\n"
"uint8 ROLE_GOALIE=5\n"
"uint8[] role\n"
"\n"
"uint8 ACTION_UNDEFINED=0\n"
"uint8 ACTION_POSITIONING=1\n"
"uint8 ACTION_GOING_TO_BALL=2\n"
"uint8 ACTION_TRYING_TO_SCORE=3\n"
"uint8 ACTION_WAITING=4\n"
"uint8[] action\n"
"\n"
"uint8 STATE_INACTIVE=0\n"
"uint8 STATE_ACTIVE=1\n"
"uint8 STATE_PENALIZED=2\n"
"uint8[] state\n"
"\n"
"# Absolute position values\n"
"geometry_msgs/Pose2D[] robot_positions\n"
"\n"
"# Relative ball position, theta of Pose2D is not used\n"
"Position2D[] ball_relative\n"
"\n"
"# Relative position of the opponent goal, theta of Pose2D is not used\n"
"# This is helpful if the robot has no global position, but sees the goal\n"
"Position2D[] oppgoal_relative\n"
"\n"
"# Positions of opponent robots, if they are recognized\n"
"# The letter of the robot is arbitrary as the sending robot does not know the id of a seen robot\n"
"Position2D[] opponent_robot_a\n"
"Position2D[] opponent_robot_b\n"
"Position2D[] opponent_robot_c\n"
"Position2D[] opponent_robot_d\n"
"\n"
"# Positions of team robots, if they are recognized\n"
"# The letter of the robot is arbitrary as the sending robot does not know the id of a seen robot\n"
"Position2D[] team_robot_a\n"
"Position2D[] team_robot_b\n"
"Position2D[] team_robot_c\n"
"\n"
"float32[] avg_walking_speed\n"
"float32[] time_to_position_at_ball\n"
"float32[] max_kicking_distance\n"
"\n"
"# Strategy over which side the team tries to attack\n"
"# Especially useful during a kickoff\n"
"uint8 UNSPECIFIED=0\n"
"uint8 LEFT=1\n"
"uint8 RIGHT=2\n"
"uint8 CENTER=3\n"
"uint8[] offensive_side\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: geometry_msgs/Pose2D\n"
"# Deprecated\n"
"# Please use the full 3D pose.\n"
"\n"
"# In general our recommendation is to use a full 3D representation of everything and for 2D specific applications make the appropriate projections into the plane for their calculations but optimally will preserve the 3D information during processing.\n"
"\n"
"# If we have parallel copies of 2D datatypes every UI and other pipeline will end up needing to have dual interfaces to plot everything. And you will end up with not being able to use 3D tools for 2D use cases even if they're completely valid, as you'd have to reimplement it with different inputs and outputs. It's not particularly hard to plot the 2D pose or compute the yaw error for the Pose message and there are already tools and libraries that can do this for you.\n"
"\n"
"\n"
"# This expresses a position and orientation on a 2D manifold.\n"
"\n"
"float64 x\n"
"float64 y\n"
"float64 theta\n"
"\n"
"================================================================================\n"
"MSG: humanoid_league_msgs/Position2D\n"
"# The position system is the same as mitecom. The following part is taken from the mitecom documentation:\n"
"# https://github.com/fumanoids/mitecom\n"
"# The origin of the absolute coordinate center is the center of the middle\n"
"# circle (center of field). The x axis points towards the opponent goal, the\n"
"# y axis to the left.\n"
"#\n"
"#      y\n"
"#      ^       ______________________\n"
"#      |    M  |          |          |  O\n"
"#      |    Y  |_ -x, y   |   x, y  _|  P\n"
"#      |    G  | |        |        | |  P\n"
"# 0    +    O  | |       ( )       | |  G\n"
"#      |    A  |_|        |        |_|  O\n"
"#      |    L  |  -x,-y   |   x,-y   |  A\n"
"#      |       |__________|__________|  L\n"
"#      |\n"
"#      +------------------+--------------> x\n"
"#                         0\n"
"#\n"
"# The 0 value of the orientation is pointing to the opponent side (right side in the image).\n"
"# The value increases counter clockwise\n"
"# Everything in meters (because it is the ROS standard)\n"
"\n"
"# The header is included to get the time stamp for later use in tf\n"
"std_msgs/Header header\n"
"\n"
"geometry_msgs/Pose2D pose\n"
"# A certainty rating between 0 and 1, where 1 is the surest.\n"
"float32 confidence\n"
;
  }

  static const char* value(const ::humanoid_league_msgs::TeamData_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::humanoid_league_msgs::TeamData_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.robot_ids);
      stream.next(m.role);
      stream.next(m.action);
      stream.next(m.state);
      stream.next(m.robot_positions);
      stream.next(m.ball_relative);
      stream.next(m.oppgoal_relative);
      stream.next(m.opponent_robot_a);
      stream.next(m.opponent_robot_b);
      stream.next(m.opponent_robot_c);
      stream.next(m.opponent_robot_d);
      stream.next(m.team_robot_a);
      stream.next(m.team_robot_b);
      stream.next(m.team_robot_c);
      stream.next(m.avg_walking_speed);
      stream.next(m.time_to_position_at_ball);
      stream.next(m.max_kicking_distance);
      stream.next(m.offensive_side);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct TeamData_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::humanoid_league_msgs::TeamData_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::humanoid_league_msgs::TeamData_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "robot_ids[]" << std::endl;
    for (size_t i = 0; i < v.robot_ids.size(); ++i)
    {
      s << indent << "  robot_ids[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.robot_ids[i]);
    }
    s << indent << "role[]" << std::endl;
    for (size_t i = 0; i < v.role.size(); ++i)
    {
      s << indent << "  role[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.role[i]);
    }
    s << indent << "action[]" << std::endl;
    for (size_t i = 0; i < v.action.size(); ++i)
    {
      s << indent << "  action[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.action[i]);
    }
    s << indent << "state[]" << std::endl;
    for (size_t i = 0; i < v.state.size(); ++i)
    {
      s << indent << "  state[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.state[i]);
    }
    s << indent << "robot_positions[]" << std::endl;
    for (size_t i = 0; i < v.robot_positions.size(); ++i)
    {
      s << indent << "  robot_positions[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::geometry_msgs::Pose2D_<ContainerAllocator> >::stream(s, indent + "    ", v.robot_positions[i]);
    }
    s << indent << "ball_relative[]" << std::endl;
    for (size_t i = 0; i < v.ball_relative.size(); ++i)
    {
      s << indent << "  ball_relative[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >::stream(s, indent + "    ", v.ball_relative[i]);
    }
    s << indent << "oppgoal_relative[]" << std::endl;
    for (size_t i = 0; i < v.oppgoal_relative.size(); ++i)
    {
      s << indent << "  oppgoal_relative[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >::stream(s, indent + "    ", v.oppgoal_relative[i]);
    }
    s << indent << "opponent_robot_a[]" << std::endl;
    for (size_t i = 0; i < v.opponent_robot_a.size(); ++i)
    {
      s << indent << "  opponent_robot_a[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >::stream(s, indent + "    ", v.opponent_robot_a[i]);
    }
    s << indent << "opponent_robot_b[]" << std::endl;
    for (size_t i = 0; i < v.opponent_robot_b.size(); ++i)
    {
      s << indent << "  opponent_robot_b[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >::stream(s, indent + "    ", v.opponent_robot_b[i]);
    }
    s << indent << "opponent_robot_c[]" << std::endl;
    for (size_t i = 0; i < v.opponent_robot_c.size(); ++i)
    {
      s << indent << "  opponent_robot_c[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >::stream(s, indent + "    ", v.opponent_robot_c[i]);
    }
    s << indent << "opponent_robot_d[]" << std::endl;
    for (size_t i = 0; i < v.opponent_robot_d.size(); ++i)
    {
      s << indent << "  opponent_robot_d[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >::stream(s, indent + "    ", v.opponent_robot_d[i]);
    }
    s << indent << "team_robot_a[]" << std::endl;
    for (size_t i = 0; i < v.team_robot_a.size(); ++i)
    {
      s << indent << "  team_robot_a[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >::stream(s, indent + "    ", v.team_robot_a[i]);
    }
    s << indent << "team_robot_b[]" << std::endl;
    for (size_t i = 0; i < v.team_robot_b.size(); ++i)
    {
      s << indent << "  team_robot_b[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >::stream(s, indent + "    ", v.team_robot_b[i]);
    }
    s << indent << "team_robot_c[]" << std::endl;
    for (size_t i = 0; i < v.team_robot_c.size(); ++i)
    {
      s << indent << "  team_robot_c[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::humanoid_league_msgs::Position2D_<ContainerAllocator> >::stream(s, indent + "    ", v.team_robot_c[i]);
    }
    s << indent << "avg_walking_speed[]" << std::endl;
    for (size_t i = 0; i < v.avg_walking_speed.size(); ++i)
    {
      s << indent << "  avg_walking_speed[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.avg_walking_speed[i]);
    }
    s << indent << "time_to_position_at_ball[]" << std::endl;
    for (size_t i = 0; i < v.time_to_position_at_ball.size(); ++i)
    {
      s << indent << "  time_to_position_at_ball[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.time_to_position_at_ball[i]);
    }
    s << indent << "max_kicking_distance[]" << std::endl;
    for (size_t i = 0; i < v.max_kicking_distance.size(); ++i)
    {
      s << indent << "  max_kicking_distance[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.max_kicking_distance[i]);
    }
    s << indent << "offensive_side[]" << std::endl;
    for (size_t i = 0; i < v.offensive_side.size(); ++i)
    {
      s << indent << "  offensive_side[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.offensive_side[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // HUMANOID_LEAGUE_MSGS_MESSAGE_TEAMDATA_H
